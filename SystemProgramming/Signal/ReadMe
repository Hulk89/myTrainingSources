-=-=-=-=-=-=-SIGNAL-=-=-=-=-=-=-

kill -l : 쓸 수 있는 signal을 알려준다.
=========================================================
hyeongseok$ kill -l

1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL
5) SIGTRAP  6) SIGABRT  7) SIGEMT   8) SIGFPE
9) SIGKILL   10) SIGBUS  11) SIGSEGV 12) SIGSYS
13) SIGPIPE  14) SIGALRM 15) SIGTERM 16) SIGURG
17) SIGSTOP  18) SIGTSTP 19) SIGCONT 20) SIGCHLD
21) SIGTTIN  22) SIGTTOU 23) SIGIO   24) SIGXCPU
25) SIGXFSZ  26) SIGVTALRM   27) SIGPROF 28) SIGWINCH
29) SIGINFO  30) SIGUSR1 31) SIGUSR2

SIGKILL  : 9  : 프로세스 죽이기
SIGALRM  : 14 : 알람을 발생
SIGSTP   : 20 : 프로세스 멈추기
SIGCONT  : 18 : 멈춰진 프로세스를 continue
SIGINT   : 2  : interrupt
SIGSEGV  : 11 : 프로세스가 다른 메모리영역을 침범

=========================================================

SIGNAL 사용 용도 - 2가지
=========================================================
비동기적 사건 발생을 통보하기 위한 용도
SIGKILL, SIGSEGV

사건을 동기화시키기위한 용도
SIGALARM



shell에서의 사용법
=========================================================
kill -signal pid
pid >  0 : 해당 pid만
    =  0 : 현재 프로세스에 속한 모든 그룹의 프로세스
    = -1 : 1번 프로세스(init)을 제외한 모든 프로세스
    < -1 : pid의 모든 그룹의 프로세스


keyboard에서의 사용법
=========================================================
Ctrl + C : SIGINT
Ctrl + Z : SIGSTP
Ctrl + \ : SIGQUIT - core dump를 하고 프로세스 종료시킨다.

SIGNAL을 받았을 때
1. 시그널을 처리할 등록된 함수를 호출한다.
2. 시그널을 무시한다.
3. 시그널을 무시하진 않지만 호출할 함수가 없다. => 기본 행동을 취한다.

기본행동
1. 프로세스가 죽는다 - 대부분의 시그널에 대한 기본행동
2. 프로세스가 중단된다.
3. 무시한다.

catch?
시그널은 catch 가능한 것과 그렇지 않은 것이 있다.
불가능한 것의 대표 - SIGKILL, SIGSTOP


SIGNAL Programming

kill의 정의
================================
#include <sys/types.h>
#include <signal.h>

int kill( pid_t pid, int sig );
================================

예제 => signal.c

signal catch
==========================================================
#include <signal.h>

typedef void (*sighandler_t)(int);
sighandler_t signal( int signum, sighandler_t handler );
==========================================================

예제 => sigint.c

sighandler_t에는 다음 두가지를 넣을 수 있다.

SIG_IGN : signal을 무시한다.
SIG_DFL : 기본행동을 한다.

DFL의 경우 최초 시그널을 무시하고 그 다음부터 시그널을 기본행동으로 제어하고 싶을 때
이런경우에 쓰인다...또는 fork시 유용하겠지....



SIGNAL의 특징
1. Queue가 없다. - 동시에 하나의 시그널만 처리 가능. => RTS(Real Time Signal)을 사용하면 된다.
2. 비신뢰성. - 단방향 통신이기 때문에 시그널이 제대로 전달되었는지 확인할 방법이 없다.


SIGNAL을 동기적으로 처리하기 위해 sigwait란 함수를 제공한다.
이는 다른 일을 하지 않고 sigset_t가 발생될 때 까지 기다린다.
==========================================================
#include <signal.h>

int sigwait( const sigset_t *set, int *sig );
==========================================================


SIGACTION

1. signal set
2. policy for signal
3. signal function

==========================================================

#include <signal.h>
int sigaction( int signum, const struct sigaction *act, struct sigaction *oldact );

struct sigaction
{
    void (*sa_handler) (int);
    void (*sa_sigaction) (int, siginfo_t *, void * );
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer) (void);
}
==========================================================

sa_handler : sigaction의 signum에 해당하는 signal이 전달됐을 때 실행될 handler
sa_mask : sa_handler에 등록된 시그널 핸들러가 실행되는 동안 블록되어야하는 signal_mask

signal을 set로 묶어서 관리...
sigprocmask : 현재 set으로 등록된 시그널의 블럭정책을 변경하기 위해 사용.
    1. SIG_BLOCK   : set에 설정된 시그널 셋을 기존 블럭셋에 추가
    2. SIG_UNBLOCK : set에 설정된 시그널 셋을 기존 블럭셋에서 제거
    3. SIG_SETMASK : set의 시그널 셋을 블럭set 정책으로 한다.
sigpending  : signal이 블록된 상태에서 어떤 시그널이 발생해서 블록되었는지 알 수 있다.
sigismember : signum이 signal set에 포함되어있는지 확인한다.
sigfillset  : 모든 시그널셋의 bitflag on
sigaddset   : signum번호를 가지는 시그널을 추가한다.
sigemptyset : set을 모두 비운다.
sigdelset   : set에서 시그널 제거
예제 => sigAction.c

실험결과!!!!

여기에서는 signal handler가 불리는 도중 다시 한번 시그널이 오는 경우
non-blocking mode로 받는 실험을 해보았다. 이 경우 나중에 들어온 시그널에 대한 핸들을
먼저 하고 그 전에 들어온 시그널, ... 이렇게 스택처럼 처리하는 것을 확인!
또한 blocking처리된 시그널에 대해서는 몇개를 보내든 다른 시그널 핸들러가 끝날 때 까지
핸들러가 뜨지 않으며 핸들러가 끝나면 나머지 하나가 불리게 된다.
다른 시그널 여러개를 블락되는 동안 발생시키면 핸들러가 끝나면서 순서대로 핸들러 하나씩 부른다!

